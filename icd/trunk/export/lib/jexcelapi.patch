diff -uNr jexcelapi/src/jxl/biff/DVParser.java patched-jexcelapi/src/jxl/biff/DVParser.java
--- jexcelapi/src/jxl/biff/DVParser.java	2009-10-06 02:35:08.000000000 -0700
+++ patched-jexcelapi/src/jxl/biff/DVParser.java	2010-10-29 09:31:22.895927017 -0700
@@ -666,9 +666,11 @@
     {
       try
       {
-        formula1String = copy.formula1.getFormula();
-        formula2String = (copy.formula2 != null) ? 
-          copy.formula2.getFormula() : null;
+	  if (copy.formula1 != null){
+	      formula1String = copy.formula1.getFormula();
+	      formula2String = (copy.formula2 != null) ? 
+		  copy.formula2.getFormula() : null;
+	  }
       }
       catch (FormulaException e)
       {
diff -uNr jexcelapi/src/jxl/biff/DVParser.java~ patched-jexcelapi/src/jxl/biff/DVParser.java~
--- jexcelapi/src/jxl/biff/DVParser.java~	1969-12-31 16:00:00.000000000 -0800
+++ patched-jexcelapi/src/jxl/biff/DVParser.java~	2009-10-06 02:35:08.000000000 -0700
@@ -0,0 +1,1042 @@
+/*********************************************************************
+*
+*      Copyright (C) 2004 Andrew Khan
+*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+***************************************************************************/
+
+package jxl.biff;
+
+import jxl.common.Assert;
+import jxl.common.Logger;
+
+import java.text.MessageFormat;
+import java.text.DecimalFormat;
+import java.util.Collection;
+import java.util.Iterator;
+
+import jxl.WorkbookSettings;
+import jxl.biff.formula.ExternalSheet;
+import jxl.biff.formula.FormulaException;
+import jxl.biff.formula.FormulaParser;
+import jxl.biff.formula.ParseContext;
+
+/**
+ * Class which parses the binary data associated with Data Validity (DV)
+ * setting
+ */
+public class DVParser
+{
+  /**
+   * The logger
+   */
+  private static Logger logger = Logger.getLogger(DVParser.class);
+
+  // DV Type
+  public static class DVType 
+  {
+    private int value;
+    private String desc;
+    
+    private static DVType[] types = new DVType[0];
+   
+    DVType(int v, String d) 
+    {
+      value = v;
+      desc = d;
+      DVType[] oldtypes = types;
+      types = new DVType[oldtypes.length+1];
+      System.arraycopy(oldtypes, 0, types, 0, oldtypes.length);
+      types[oldtypes.length] = this;
+    }
+
+    static DVType getType(int v)
+    {
+      DVType found = null;
+      for (int i = 0 ; i < types.length && found == null ; i++)
+      {
+        if (types[i].value == v)
+        {
+          found = types[i];
+        }
+      }
+      return found;
+    }
+
+    public int getValue() 
+    {
+      return value;
+    }
+
+    public String getDescription()
+    {
+      return desc;
+    }
+  }
+
+  // Error Style
+  public static class ErrorStyle
+  {
+    private int value;
+    
+    private static ErrorStyle[] types = new ErrorStyle[0];
+   
+    ErrorStyle(int v) 
+    {
+      value = v;
+      ErrorStyle[] oldtypes = types;
+      types = new ErrorStyle[oldtypes.length+1];
+      System.arraycopy(oldtypes, 0, types, 0, oldtypes.length);
+      types[oldtypes.length] = this;
+    }
+
+    static ErrorStyle getErrorStyle(int v)
+    {
+      ErrorStyle found = null;
+      for (int i = 0 ; i < types.length && found == null ; i++)
+      {
+        if (types[i].value == v)
+        {
+          found = types[i];
+        }
+      }
+      return found;
+    }
+
+    public int getValue() 
+    {
+      return value;
+    }
+  }
+
+  // Conditions
+  public static class Condition
+  {
+    private int value;
+    private MessageFormat format;
+    
+    private static Condition[] types = new Condition[0];
+   
+    Condition(int v, String pattern) 
+    {
+      value = v;
+      format = new MessageFormat(pattern);
+      Condition[] oldtypes = types;
+      types = new Condition[oldtypes.length+1];
+      System.arraycopy(oldtypes, 0, types, 0, oldtypes.length);
+      types[oldtypes.length] = this;
+    }
+
+    static Condition getCondition(int v)
+    {
+      Condition found = null;
+      for (int i = 0 ; i < types.length && found == null ; i++)
+      {
+        if (types[i].value == v)
+        {
+          found = types[i];
+        }
+      }
+      return found;
+    }
+
+    public int getValue() 
+    {
+      return value;
+    }
+
+    public String getConditionString(String s1, String s2)
+    {
+      return format.format(new String[] {s1, s2});
+    }
+  }
+
+  // The values
+  public static final DVType ANY = new DVType(0, "any");
+  public static final DVType INTEGER = new DVType(1, "int");
+  public static final DVType DECIMAL = new DVType(2, "dec");
+  public static final DVType LIST = new DVType(3, "list");
+  public static final DVType DATE = new DVType(4, "date");
+  public static final DVType TIME = new DVType(5, "time");
+  public static final DVType TEXT_LENGTH = new DVType(6, "strlen");
+  public static final DVType FORMULA = new DVType(7, "form");
+
+  // The error styles
+  public static final ErrorStyle STOP = new ErrorStyle(0);
+  public static final ErrorStyle WARNING = new ErrorStyle(1);
+  public static final ErrorStyle INFO = new ErrorStyle(2);
+
+  // The conditions
+  public static final Condition BETWEEN = new Condition(0, "{0} <= x <= {1}");
+  public static final Condition NOT_BETWEEN = 
+    new Condition(1, "!({0} <= x <= {1}");
+  public static final Condition EQUAL = new Condition(2, "x == {0}");
+  public static final Condition NOT_EQUAL = new Condition(3, "x != {0}");
+  public static final Condition GREATER_THAN = new Condition(4, "x > {0}");
+  public static final Condition LESS_THAN = new Condition(5, "x < {0}");
+  public static final Condition GREATER_EQUAL = new Condition(6, "x >= {0}");
+  public static final Condition LESS_EQUAL = new Condition(7, "x <= {0}");
+
+  // The masks
+  private static final int STRING_LIST_GIVEN_MASK = 0x80;
+  private static final int EMPTY_CELLS_ALLOWED_MASK = 0x100;
+  private static final int SUPPRESS_ARROW_MASK = 0x200;
+  private static final int SHOW_PROMPT_MASK = 0x40000;
+  private static final int SHOW_ERROR_MASK = 0x80000;
+
+  // The decimal format
+  private static DecimalFormat DECIMAL_FORMAT = new DecimalFormat("#.#");
+
+  // The maximum string length for a data validation list
+  private static final int MAX_VALIDATION_LIST_LENGTH = 254;
+
+  // The maximum number of rows and columns
+  private static final int MAX_ROWS=0xffff;
+  private static final int MAX_COLUMNS=0xff;
+
+  /**
+   * The type
+   */
+  private DVType type;
+
+  /**
+   * The error style
+   */
+  private ErrorStyle errorStyle;
+
+  /**
+   * The condition
+   */
+  private Condition condition;
+
+  /**
+   * String list option
+   */
+  private boolean stringListGiven;
+
+  /**
+   * Empty cells allowed
+   */
+  private boolean emptyCellsAllowed;
+
+  /**
+   * Suppress arrow
+   */
+  private boolean suppressArrow;
+
+  /**
+   * Show prompt
+   */
+  private boolean showPrompt;
+
+  /**
+   * Show error
+   */
+  private boolean showError;
+
+  /**
+   * The title of the prompt box
+   */
+  private String promptTitle;
+
+  /**
+   * The title of the error box
+   */
+  private String errorTitle;
+
+  /**
+   * The text of the prompt box
+   */
+  private String promptText;
+
+  /**
+   * The text of the error box
+   */
+  private String errorText;
+
+  /**
+   * The first formula
+   */
+  private FormulaParser formula1;
+
+  /**
+   * The first formula string
+   */
+  private String formula1String;
+
+  /**
+   * The second formula
+   */
+  private FormulaParser formula2;
+
+  /**
+   * The second formula string
+   */
+  private String formula2String;
+
+  /**
+   * The column number of the cell at the top left of the range
+   */
+  private int column1;
+
+  /**
+   * The row number of the cell at the top left of the range
+   */
+  private int row1;
+
+  /**
+   * The column index of the cell at the bottom right
+   */
+  private int column2;
+
+  /**
+   * The row index of the cell at the bottom right
+   */
+  private int row2;
+
+  /**
+   * Flag to indicate that this DV Parser is shared amongst a group
+   * of cells
+   */
+  private boolean extendedCellsValidation;
+
+  /**
+   * Flag indicated whether this has been copied
+   */
+  private boolean copied;
+
+  /**
+   * Constructor
+   */
+  public DVParser(byte[] data, 
+                  ExternalSheet es, 
+                  WorkbookMethods nt,
+                  WorkbookSettings ws)
+  {
+    Assert.verify(nt != null);
+
+    copied = false;
+    int options = IntegerHelper.getInt(data[0], data[1], data[2], data[3]);
+
+    int typeVal = options & 0xf;
+    type = DVType.getType(typeVal);
+
+    int errorStyleVal = (options & 0x70) >> 4;
+    errorStyle = ErrorStyle.getErrorStyle(errorStyleVal);
+
+    int conditionVal = (options & 0xf00000) >> 20;
+    condition = Condition.getCondition(conditionVal);
+
+    stringListGiven = (options & STRING_LIST_GIVEN_MASK) != 0;
+    emptyCellsAllowed = (options & EMPTY_CELLS_ALLOWED_MASK) != 0;
+    suppressArrow = (options & SUPPRESS_ARROW_MASK) != 0;
+    showPrompt = (options & SHOW_PROMPT_MASK) != 0;
+    showError = (options & SHOW_ERROR_MASK) != 0;
+
+    int pos = 4;
+    int length = IntegerHelper.getInt(data[pos], data[pos+1]);
+    if (length > 0 && data[pos + 2] == 0)
+    {
+      promptTitle = StringHelper.getString(data, length, pos + 3, ws);
+      pos += length + 3;
+    }
+    else if (length > 0)
+    {
+      promptTitle = StringHelper.getUnicodeString(data, length, pos + 3);
+      pos += length * 2 + 3;
+    }
+    else
+    {
+      pos += 3;
+    }
+
+    length = IntegerHelper.getInt(data[pos], data[pos+1]);
+    if (length > 0 && data[pos + 2] == 0)
+    {
+      errorTitle = StringHelper.getString(data, length, pos + 3, ws);
+      pos += length + 3;
+    }
+    else if (length > 0)
+    {
+      errorTitle = StringHelper.getUnicodeString(data, length, pos + 3);
+      pos += length * 2 + 3;
+    }
+    else
+    {
+      pos += 3;
+    }
+
+    length = IntegerHelper.getInt(data[pos], data[pos+1]);
+    if (length > 0 && data[pos + 2] == 0)
+    {
+      promptText = StringHelper.getString(data, length, pos + 3, ws);
+      pos += length + 3;
+    }
+    else if (length > 0)
+    {
+      promptText = StringHelper.getUnicodeString(data, length, pos + 3);
+      pos += length * 2 + 3;
+    }
+    else
+    {
+      pos += 3;
+    }
+
+    length = IntegerHelper.getInt(data[pos], data[pos+1]);
+    if (length > 0 && data[pos + 2] == 0)
+    {
+      errorText = StringHelper.getString(data, length, pos + 3, ws);
+      pos += length + 3;
+    }
+    else if (length > 0)
+    {
+      errorText = StringHelper.getUnicodeString(data, length, pos + 3);
+      pos += length * 2 + 3;
+    }
+    else
+    {
+      pos += 3;
+    }
+
+    int formula1Length = IntegerHelper.getInt(data[pos], data[pos+1]);
+    pos += 4;
+    int formula1Pos = pos;
+    pos += formula1Length;
+
+    int formula2Length = IntegerHelper.getInt(data[pos], data[pos+1]);
+    pos += 4;
+    int formula2Pos = pos;
+    pos += formula2Length;
+
+    pos += 2;
+
+    row1 = IntegerHelper.getInt(data[pos], data[pos+1]);
+    pos += 2;
+
+    row2 = IntegerHelper.getInt(data[pos], data[pos+1]);
+    pos += 2;
+
+    column1 = IntegerHelper.getInt(data[pos], data[pos+1]);
+    pos += 2;
+
+    column2 = IntegerHelper.getInt(data[pos], data[pos+1]);
+    pos += 2;
+
+    extendedCellsValidation = (row1 == row2 && column1 == column2) ? 
+      false : true;
+
+    // Do the formulas
+    try
+    {
+      // First, create a temporary  blank cell for any formula relative 
+      // references
+      EmptyCell tmprt = new EmptyCell(column1, row1);
+
+      if (formula1Length != 0)
+      {
+        byte[] tokens = new byte[formula1Length];
+        System.arraycopy(data, formula1Pos, tokens, 0, formula1Length);
+        formula1 = new FormulaParser(tokens, tmprt, es, nt,ws, 
+                                     ParseContext.DATA_VALIDATION);
+        formula1.parse();
+      }
+
+      if (formula2Length != 0)
+      {
+        byte[] tokens = new byte[formula2Length];
+        System.arraycopy(data, formula2Pos, tokens, 0, formula2Length);
+        formula2 = new FormulaParser(tokens, tmprt, es, nt, ws, 
+                                     ParseContext.DATA_VALIDATION);
+        formula2.parse();
+      }
+    }
+    catch (FormulaException e)
+    {
+      logger.warn(e.getMessage() + " for cells " + 
+      CellReferenceHelper.getCellReference(column1, row1)+ "-" + 
+      CellReferenceHelper.getCellReference(column2, row2));
+    }
+  }
+
+  /**
+   * Constructor called when creating a data validation from the API
+   */
+  public DVParser(Collection strings)
+  {
+    copied = false;
+    type = LIST;
+    errorStyle = STOP;
+    condition = BETWEEN;
+    extendedCellsValidation = false;
+    
+    // the options
+    stringListGiven = true;
+    emptyCellsAllowed = true;
+    suppressArrow = false;
+    showPrompt = true;
+    showError = true;
+
+    promptTitle = "\0";
+    errorTitle = "\0";
+    promptText = "\0";
+    errorText = "\0";
+    if (strings.size() == 0)
+    {
+      logger.warn("no validation strings - ignoring");
+    }
+
+    Iterator i = strings.iterator();
+    StringBuffer formulaString = new StringBuffer();
+
+    formulaString.append(i.next().toString());
+    while (i.hasNext())
+    {
+      formulaString.append('\0');
+      formulaString.append(' ');
+      formulaString.append(i.next().toString());
+    }
+
+    // If the formula string exceeds
+    // the maximum validation list length, then truncate and stop there
+    if (formulaString.length() > MAX_VALIDATION_LIST_LENGTH)
+    {
+      logger.warn("Validation list exceeds maximum number of characters - " +
+                  "truncating");
+      formulaString.delete(MAX_VALIDATION_LIST_LENGTH, 
+                           formulaString.length());
+    }
+
+    // Put the string in quotes
+    formulaString.insert(0, '\"');
+    formulaString.append('\"');
+    formula1String = formulaString.toString();
+  }
+
+  /**
+   * Constructor called when creating a data validation from the API
+   */
+  public DVParser(String namedRange)
+  {
+    // Handle the case for an empty string
+    if (namedRange.length() == 0)
+    {
+      copied = false;
+      type = FORMULA;
+      errorStyle = STOP;
+      condition = EQUAL;
+      extendedCellsValidation = false;
+      // the options
+      stringListGiven = false;
+      emptyCellsAllowed = false;
+      suppressArrow = false;
+      showPrompt = true;
+      showError = true;
+      
+      promptTitle = "\0";
+      errorTitle = "\0";
+      promptText = "\0";
+      errorText = "\0";
+      formula1String = "\"\"";
+      return;
+    }
+
+    copied = false;
+    type = LIST;
+    errorStyle = STOP;
+    condition = BETWEEN;
+    extendedCellsValidation = false;
+    
+    // the options
+    stringListGiven = false;
+    emptyCellsAllowed = true;
+    suppressArrow = false;
+    showPrompt = true;
+    showError = true;
+
+    promptTitle = "\0";
+    errorTitle = "\0";
+    promptText = "\0";
+    errorText = "\0";
+    formula1String = namedRange;
+  }
+
+  /**
+   * Constructor called when creating a data validation from the API
+   */
+  public DVParser(int c1, int r1, int c2, int r2)
+  {
+    copied = false;
+    type = LIST;
+    errorStyle = STOP;
+    condition = BETWEEN;
+    extendedCellsValidation = false;
+    
+    // the options
+    stringListGiven = false;
+    emptyCellsAllowed = true;
+    suppressArrow = false;
+    showPrompt = true;
+    showError = true;
+
+    promptTitle = "\0";
+    errorTitle = "\0";
+    promptText = "\0";
+    errorText = "\0";
+    StringBuffer formulaString = new StringBuffer();
+    CellReferenceHelper.getCellReference(c1,r1,formulaString);
+    formulaString.append(':');
+    CellReferenceHelper.getCellReference(c2,r2,formulaString);
+    formula1String = formulaString.toString();
+  }
+
+  /**
+   * Constructor called when creating a data validation from the API
+   */
+  public DVParser(double val1, double val2, Condition c)
+  {
+    copied = false;
+    type = DECIMAL;
+    errorStyle = STOP;
+    condition = c;
+    extendedCellsValidation = false;
+    
+    // the options
+    stringListGiven = false;
+    emptyCellsAllowed = true;
+    suppressArrow = false;
+    showPrompt = true;
+    showError = true;
+
+    promptTitle = "\0";
+    errorTitle = "\0";
+    promptText = "\0";
+    errorText = "\0";
+    formula1String = DECIMAL_FORMAT.format(val1);
+
+    if (!Double.isNaN(val2))
+    {
+      formula2String = DECIMAL_FORMAT.format(val2);
+    }
+  }
+
+  /**
+   * Constructor called when doing a cell deep copy
+   */
+  public DVParser(DVParser copy)
+  {
+    copied = true;
+    type = copy.type;
+    errorStyle = copy.errorStyle;
+    condition = copy.condition;
+    stringListGiven = copy.stringListGiven;
+    emptyCellsAllowed = copy.emptyCellsAllowed;
+    suppressArrow = copy.suppressArrow;
+    showPrompt = copy.showPrompt;
+    showError = copy.showError;
+    promptTitle = copy.promptTitle;
+    promptText = copy.promptText;
+    errorTitle = copy.errorTitle;
+    errorText = copy.errorText;
+    extendedCellsValidation = copy.extendedCellsValidation;
+
+    row1 = copy.row1;
+    row2 = copy.row2;
+    column1 = copy.column1;
+    column2 = copy.column2;
+
+    // Don't copy the formula parsers - just take their string equivalents
+    if (copy.formula1String != null)
+    {
+      formula1String = copy.formula1String;
+      formula2String = copy.formula2String;
+    }
+    else
+    {
+      try
+      {
+        formula1String = copy.formula1.getFormula();
+        formula2String = (copy.formula2 != null) ? 
+          copy.formula2.getFormula() : null;
+      }
+      catch (FormulaException e)
+      {
+        logger.warn("Cannot parse validation formula:  " + e.getMessage());
+      }
+    }
+    // Don't copy the cell references - these will be added later
+  }
+
+  /**
+   * Gets the data
+   */
+  public byte[] getData()
+  {
+    // Compute the length of the data
+    byte[] f1Bytes = formula1 != null ? formula1.getBytes() : new byte[0];
+    byte[] f2Bytes = formula2 != null ? formula2.getBytes() : new byte[0];
+    int dataLength = 
+      4 + // the options
+      promptTitle.length() * 2 + 3 + // the prompt title
+      errorTitle.length() * 2 + 3 + // the error title
+      promptText.length() * 2 + 3 + // the prompt text
+      errorText.length() * 2 + 3 + // the error text
+      f1Bytes.length + 2 + // first formula
+      f2Bytes.length + 2 + // second formula
+      + 4 + // unused bytes
+      10; // cell range
+
+    byte[] data = new byte[dataLength];
+
+    // The position
+    int pos = 0;
+
+    // The options
+    int options = 0;
+    options |= type.getValue();
+    options |= errorStyle.getValue() << 4;
+    options |= condition.getValue() << 20;
+
+    if (stringListGiven) 
+    {
+      options |= STRING_LIST_GIVEN_MASK;
+    }
+
+    if (emptyCellsAllowed) 
+    {
+      options |= EMPTY_CELLS_ALLOWED_MASK;
+    }
+
+    if (suppressArrow)
+    {
+      options |= SUPPRESS_ARROW_MASK;
+    }
+
+    if (showPrompt)
+    {
+      options |= SHOW_PROMPT_MASK;
+    }
+
+    if (showError)
+    {
+      options |= SHOW_ERROR_MASK;
+    }
+
+    // The text
+    IntegerHelper.getFourBytes(options, data, pos);
+    pos += 4;
+    
+    IntegerHelper.getTwoBytes(promptTitle.length(), data, pos);
+    pos += 2;
+
+    data[pos] = (byte) 0x1; // unicode indicator
+    pos++;
+
+    StringHelper.getUnicodeBytes(promptTitle, data, pos);
+    pos += promptTitle.length() * 2;
+
+    IntegerHelper.getTwoBytes(errorTitle.length(), data, pos);
+    pos += 2;
+
+    data[pos] = (byte) 0x1; // unicode indicator
+    pos++;
+
+    StringHelper.getUnicodeBytes(errorTitle, data, pos);
+    pos += errorTitle.length() * 2;
+
+    IntegerHelper.getTwoBytes(promptText.length(), data, pos);
+    pos += 2;
+
+    data[pos] = (byte) 0x1; // unicode indicator
+    pos++;
+
+    StringHelper.getUnicodeBytes(promptText, data, pos);
+    pos += promptText.length() * 2;
+
+    IntegerHelper.getTwoBytes(errorText.length(), data, pos);
+    pos += 2;
+
+    data[pos] = (byte) 0x1; // unicode indicator
+    pos++;
+
+    StringHelper.getUnicodeBytes(errorText, data, pos);
+    pos += errorText.length() * 2;
+
+    // Formula 1
+    IntegerHelper.getTwoBytes(f1Bytes.length, data, pos);
+    pos += 4;
+
+    System.arraycopy(f1Bytes, 0, data, pos, f1Bytes.length);
+    pos += f1Bytes.length;
+
+    // Formula 2
+    IntegerHelper.getTwoBytes(f2Bytes.length, data, pos);
+    pos += 4;
+    
+    System.arraycopy(f2Bytes, 0, data, pos, f2Bytes.length);
+    pos += f2Bytes.length;
+
+    // The cell ranges
+    IntegerHelper.getTwoBytes(1, data, pos);
+    pos += 2;
+
+    IntegerHelper.getTwoBytes(row1, data, pos);
+    pos += 2;
+
+    IntegerHelper.getTwoBytes(row2, data, pos);
+    pos += 2;
+
+    IntegerHelper.getTwoBytes(column1, data, pos);
+    pos += 2;
+
+    IntegerHelper.getTwoBytes(column2, data, pos);
+    pos += 2;
+
+    return data;
+  }
+
+  /**
+   * Inserts a row
+   *
+   * @param row the row to insert
+   */
+  public void insertRow(int row)
+  {
+    if (formula1 != null)
+    {
+      formula1.rowInserted(0, row, true);
+    }
+
+    if (formula2 != null)
+    {
+      formula2.rowInserted(0, row, true);
+    }
+
+    if (row1 >= row)
+    {
+      row1++;
+    }
+
+    if (row2 >= row && row2 != MAX_ROWS)
+    {
+      row2++;
+    }
+  }
+
+  /**
+   * Inserts a column
+   *
+   * @param col the column to insert
+   */
+  public void insertColumn(int col)
+  {
+    if (formula1 != null)
+    {
+      formula1.columnInserted(0, col, true);
+    }
+
+    if (formula2 != null)
+    {
+      formula2.columnInserted(0, col, true);
+    }
+
+    if (column1 >= col)
+    {
+      column1++;
+    }
+
+    if (column2 >= col && column2 != MAX_COLUMNS)
+    {
+      column2++;
+    }
+  }
+
+  /**
+   * Removes a row
+   *
+   * @param row the row to insert
+   */
+  public void removeRow(int row)
+  {
+    if (formula1 != null)
+    {
+      formula1.rowRemoved(0, row, true);
+    }
+
+    if (formula2 != null)
+    {
+      formula2.rowRemoved(0, row, true);
+    }
+
+    if (row1 > row)
+    {
+      row1--;
+    }
+
+    if (row2 >= row)
+    {
+      row2--;
+    }
+  }
+
+  /**
+   * Removes a column
+   *
+   * @param col the row to remove
+   */
+  public void removeColumn(int col)
+  {
+    if (formula1 != null)
+    {
+      formula1.columnRemoved(0, col, true);
+    }
+
+    if (formula2 != null)
+    {
+      formula2.columnRemoved(0, col, true);
+    }
+
+    if (column1 > col)
+    {
+      column1--;
+    }
+
+    if (column2 >= col && column2 != MAX_COLUMNS)
+    {
+      column2--;
+    }
+  }
+
+  /**
+   * Accessor for first column
+   *
+   * @return the first column
+   */
+  public int getFirstColumn()
+  {
+    return column1;
+  }
+
+  /**
+   * Accessor for the last column
+   *
+   * @return the last column
+   */
+  public int getLastColumn()
+  {
+    return column2;
+  }
+
+  /**
+   * Accessor for first row
+   *
+   * @return the first row
+   */
+  public int getFirstRow()
+  {
+    return row1;
+  }
+
+  /**
+   * Accessor for the last row
+   *
+   * @return the last row
+   */
+  public int getLastRow()
+  {
+    return row2;
+  }
+
+  /**
+   * Gets the formula present in the validation
+   *
+   * @return the validation formula as a string
+   * @exception FormulaException
+   */
+  String getValidationFormula() throws FormulaException
+  {
+    if (type == LIST)
+    {
+      return formula1.getFormula();
+    }
+
+    String s1 = formula1.getFormula();
+    String s2 = formula2 != null ? formula2.getFormula() : null;
+    return condition.getConditionString(s1, s2) + 
+      "; x " + type.getDescription();
+  }
+
+  /**
+   * Called by the cell value when the cell features are added to the sheet
+   */
+  public void setCell(int col, 
+                      int row, 
+                      ExternalSheet es, 
+                      WorkbookMethods nt,
+                      WorkbookSettings ws) throws FormulaException
+  {
+    // If this is part of an extended cells validation, then do nothing
+    // as this will already have been called and parsed when the top left
+    // cell was added
+    if (extendedCellsValidation)
+    {
+      return;
+    }
+
+    row1 = row;
+    row2 = row;
+    column1 = col;
+    column2 = col;
+
+    formula1 = new FormulaParser(formula1String,
+                                 es, nt, ws, 
+                                 ParseContext.DATA_VALIDATION);
+    formula1.parse();
+
+    if (formula2String != null)
+    {
+      formula2 = new FormulaParser(formula2String,
+                                   es, nt, ws, 
+                                   ParseContext.DATA_VALIDATION);
+      formula2.parse();
+    }
+  }
+
+  /**
+   * Indicates that the data validation extends across several more cells
+   *
+   * @param cols - the number of extra columns
+   * @param rows - the number of extra rows
+   */
+  public void extendCellValidation(int cols, int rows)
+  {
+    row2 = row1 + rows;
+    column2 = column1 + cols;
+    extendedCellsValidation = true;
+  }
+
+  /**
+   * Accessor which indicates whether this validation applies across
+   * multiple cels
+   */
+  public boolean extendedCellsValidation()
+  {
+    return extendedCellsValidation;
+  }
+
+  public boolean copied()
+  {
+    return copied;
+  }
+}
diff -uNr jexcelapi/src/jxl/demo/#ReadWrite.java# patched-jexcelapi/src/jxl/demo/#ReadWrite.java#
--- jexcelapi/src/jxl/demo/#ReadWrite.java#	1969-12-31 16:00:00.000000000 -0800
+++ patched-jexcelapi/src/jxl/demo/#ReadWrite.java#	2010-10-19 14:46:58.485891179 -0700
@@ -0,0 +1,461 @@
+/*********************************************************************
+*
+*      Copyright (C) 2002 Andrew Khan
+*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+***************************************************************************/
+
+package jxl.demo;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+
+import jxl.common.Logger;
+
+import jxl.Cell;
+import jxl.CellReferenceHelper;
+import jxl.CellType;
+import jxl.Range;
+import jxl.Sheet;
+import jxl.Workbook;
+import jxl.format.CellFormat;
+import jxl.format.Colour;
+import jxl.format.UnderlineStyle;
+import jxl.read.biff.BiffException;
+import jxl.write.Blank;
+import jxl.write.DateFormat;
+import jxl.write.DateFormats;
+import jxl.write.DateTime;
+import jxl.write.Formula;
+import jxl.write.Label;
+import jxl.write.Number;
+import jxl.write.NumberFormat;
+import jxl.write.WritableCell;
+import jxl.write.WritableCellFeatures;
+import jxl.write.WritableCellFormat;
+import jxl.write.WritableFont;
+import jxl.write.WritableHyperlink;
+import jxl.write.WritableImage;
+import jxl.write.WritableSheet;
+import jxl.write.WritableWorkbook;
+import jxl.write.WriteException;
+
+/**
+ * Demo class which uses the api to read in a spreadsheet and generate a clone
+ * of that spreadsheet which contains the same data.  If the spreadsheet read
+ * in is the spreadsheet called jxlrwtest.xls (provided with the distribution)
+ * then this class will modify certain fields in the copy of that spreadsheet.
+ * This is illustrating that it is possible to read in a spreadsheet, modify
+ * a few values, and write it under a new name.
+ */
+public class ReadWrite
+{
+  /**
+   * The logger
+   */
+  private static Logger logger = Logger.getLogger(ReadWrite.class);
+
+  /**
+   * The spreadsheet to read in
+   */
+  private File inputWorkbook;
+  /**
+   * The spreadsheet to output
+   */
+  private File outputWorkbook;
+
+  /**
+   * Constructor
+   * 
+   * @param output 
+   * @param input 
+   */
+  public ReadWrite(String input, String output)
+  {
+    inputWorkbook = new File(input);
+    outputWorkbook = new File(output);
+    logger.setSuppressWarnings(Boolean.getBoolean("jxl.nowarnings"));
+    logger.info("Input file:  " + input);    
+    logger.info("Output file:  " + output);
+  }
+
+  /**
+   * Reads in the inputFile and creates a writable copy of it called outputFile
+   * 
+   * @exception IOException 
+   * @exception BiffException 
+   */
+  public void readWrite() throws IOException, BiffException, WriteException
+  {
+    logger.info("Reading...");
+    Workbook w1 = Workbook.getWorkbook(inputWorkbook);
+
+    logger.info("Copying...");
+    WritableWorkbook w2 = Workbook.createWorkbook(outputWorkbook, w1);
+
+    if (inputWorkbook.getName().equals("jxlrwtest.xls"))
+    {
+      modify(w2);
+    }
+
+    w2.write();
+    w2.close();
+    logger.info("Done");
+  }
+
+  /**
+   * If the inputFile was the test spreadsheet, then it modifies certain fields
+   * of the writable copy
+   * 
+   * @param w 
+   */
+  private void modify(WritableWorkbook w) throws WriteException
+  {
+    logger.info("Modifying...");
+
+    WritableSheet sheet = w.getSheet("modified");
+    
+    WritableCell cell = null;
+    CellFormat cf = null;
+    Label l = null;
+    WritableCellFeatures wcf = null;
+
+    // Change the format of cell B4 to be emboldened
+    cell = sheet.getWritableCell(1,3);
+    WritableFont bold = new WritableFont(WritableFont.ARIAL, 
+                                         WritableFont.DEFAULT_POINT_SIZE, 
+                                         WritableFont.BOLD);
+    cf = new WritableCellFormat(bold);
+    cell.setCellFormat(cf);
+
+    // Change the format of cell B5 to be underlined
+    cell = sheet.getWritableCell(1,4);
+    WritableFont underline = new WritableFont(WritableFont.ARIAL,
+                                              WritableFont.DEFAULT_POINT_SIZE,
+                                              WritableFont.NO_BOLD,
+                                              false,
+                                              UnderlineStyle.SINGLE);
+    cf = new WritableCellFormat(underline);
+    cell.setCellFormat(cf);
+
+    // Change the point size of cell B6 to be 10 point
+    cell = sheet.getWritableCell(1,5);
+    WritableFont tenpoint = new WritableFont(WritableFont.ARIAL, 10);
+    cf = new WritableCellFormat(tenpoint);
+    cell.setCellFormat(cf);
+
+    // Change the contents of cell B7 to read "Label - mod"
+    cell = sheet.getWritableCell(1,6);
+    if (cell.getType() == CellType.LABEL)
+    {
+      Label lc = (Label) cell;
+      lc.setString(lc.getString() + " - mod");
+    }
+
+    // Change cell B10 to display 7 dps
+    cell = sheet.getWritableCell(1,9);
+    NumberFormat sevendps = new NumberFormat("#.0000000");
+    cf = new WritableCellFormat(sevendps);
+    cell.setCellFormat(cf);
+
+    
+    // Change cell B11 to display in the format 1e4
+    cell = sheet.getWritableCell(1,10);
+    NumberFormat exp4 = new NumberFormat("0.####E0");
+    cf = new WritableCellFormat(exp4);
+    cell.setCellFormat(cf);
+    
+    // Change cell B12 to be normal display
+    cell = sheet.getWritableCell(1,11);
+    cell.setCellFormat(WritableWorkbook.NORMAL_STYLE);
+
+    // Change the contents of cell B13 to 42
+    cell = sheet.getWritableCell(1,12);
+    if (cell.getType() == CellType.NUMBER)
+    {
+      Number n = (Number) cell;
+      n.setValue(42);
+    }
+
+    // Add 0.1 to the contents of cell B14
+    cell = sheet.getWritableCell(1,13);
+    if (cell.getType() == CellType.NUMBER)
+    {
+      Number n = (Number) cell;
+      n.setValue(n.getValue() + 0.1);
+    }
+
+    // Change the date format of cell B17 to be a custom format
+    cell = sheet.getWritableCell(1,16);
+    DateFormat df = new DateFormat("dd MMM yyyy HH:mm:ss");
+    cf = new WritableCellFormat(df);
+    cell.setCellFormat(cf);
+
+    // Change the date format of cell B18 to be a standard format
+    cell = sheet.getWritableCell(1,17);
+    cf = new WritableCellFormat(DateFormats.FORMAT9);
+    cell.setCellFormat(cf);
+
+    // Change the date in cell B19 to be 18 Feb 1998, 11:23:28
+    cell = sheet.getWritableCell(1,18);
+    if (cell.getType() == CellType.DATE)
+    {
+      DateTime dt = (DateTime) cell;
+      Calendar cal = Calendar.getInstance();
+      cal.set(1998, 1, 18, 11, 23, 28);
+      Date d = cal.getTime();
+      dt.setDate(d);
+    }
+
+    // Change the value in B23 to be 6.8.  This should recalculate the 
+    // formula
+    cell = sheet.getWritableCell(1,22);
+    if (cell.getType() == CellType.NUMBER)
+    {
+      Number n = (Number) cell;
+      n.setValue(6.8);
+    }
+
+    // Change the label in B30.  This will have the effect of making
+    // the original string unreferenced
+    cell = sheet.getWritableCell(1, 29);
+    if (cell.getType() == CellType.LABEL)
+    {
+      l = (Label) cell;
+      l.setString("Modified string contents");
+    }
+    // Insert a new row (number 35)
+    sheet.insertRow(34);
+
+    // Delete row 38 (39 after row has been inserted)
+    sheet.removeRow(38);
+
+    // Insert a new column (J)
+    sheet.insertColumn(9);
+
+    // Remove a column (L - M after column has been inserted)
+    sheet.removeColumn(11);
+
+    // Remove row 44 (contains a hyperlink), and then insert an empty
+    // row just to keep the numbers consistent
+    sheet.removeRow(43);
+    sheet.insertRow(43);
+
+    // Modify the hyperlinks
+    WritableHyperlink hyperlinks[] = sheet.getWritableHyperlinks();
+
+    for (int i = 0; i < hyperlinks.length; i++)
+    {
+      WritableHyperlink wh = hyperlinks[i];
+      if (wh.getColumn() == 1 && wh.getRow() == 39)
+      {
+        try
+        {
+          // Change the hyperlink that begins in cell B40 to be a different API
+          wh.setURL(new URL("http://www.andykhan.com/jexcelapi/index.html"));
+        }
+        catch (MalformedURLException e)
+        {
+          logger.warn(e.toString());
+        }
+      }
+      else if (wh.getColumn() == 1 && wh.getRow() == 40)
+      {
+        wh.setFile(new File("../jexcelapi/docs/overview-summary.html"));
+      }
+      else if (wh.getColumn() == 1 && wh.getRow() == 41)
+      {
+        wh.setFile(new File("d:/home/jexcelapi/docs/jxl/package-summary.html"));
+      }
+      else if (wh.getColumn() == 1 && wh.getRow() == 44)
+      {
+        // Remove the hyperlink at B45
+        sheet.removeHyperlink(wh);
+      }
+    }
+    
+    // Change the background of cell F31 from blue to red
+    WritableCell c = sheet.getWritableCell(5,30);
+    WritableCellFormat newFormat = new WritableCellFormat(c.getCellFormat());
+    newFormat.setBackground(Colour.RED);
+    c.setCellFormat(newFormat);
+
+    // Modify the contents of the merged cell
+    l = new Label(0, 49, "Modified merged cells");
+    sheet.addCell(l);
+
+    // Modify the chart data
+    Number n = (Number) sheet.getWritableCell(0, 70);
+    n.setValue(9);
+    
+    n = (Number) sheet.getWritableCell(0, 71);
+    n.setValue(10);
+
+    n = (Number) sheet.getWritableCell(0, 73);
+    n.setValue(4);
+
+    // Add in a cross sheet formula
+    Formula f = new Formula(1, 80, "ROUND(COS(original!B10),2)");
+    sheet.addCell(f);
+
+    // Add in a formula from the named cells
+    f = new Formula(1, 83, "value1+value2");
+    sheet.addCell(f);
+
+    // Add in a function formula using named cells
+    f = new Formula(1, 84, "AVERAGE(value1,value1*4,value2)");
+    sheet.addCell(f);
+
+    // Copy sheet 1 to sheet 3
+    //     w.copySheet(0, "copy", 2);
+
+    // Use the cell deep copy feature
+    Label label = new Label(0, 88, "Some copied cells", cf);
+    sheet.addCell(label);
+
+    label = new Label(0,89, "Number from B9");
+    sheet.addCell(label);
+
+    WritableCell wc = sheet.getWritableCell(1, 9).copyTo(1,89);
+    sheet.addCell(wc);
+
+    label = new Label(0, 90, "Label from B4 (modified format)");
+    sheet.addCell(label);
+
+    wc = sheet.getWritableCell(1, 3).copyTo(1,90);
+    sheet.addCell(wc);
+
+    label = new Label(0, 91, "Date from B17");
+    sheet.addCell(label);
+
+    wc = sheet.getWritableCell(1, 16).copyTo(1,91);
+    sheet.addCell(wc);
+
+    label = new Label(0, 92, "Boolean from E16");
+    sheet.addCell(label);
+
+    wc = sheet.getWritableCell(4, 15).copyTo(1,92);
+    sheet.addCell(wc);
+
+    label = new Label(0, 93, "URL from B40");
+    sheet.addCell(label);
+
+    wc = sheet.getWritableCell(1, 39).copyTo(1,93);
+    sheet.addCell(wc);
+
+    // Add some numbers for the formula copy
+    for (int i = 0 ; i < 6; i++)
+    {
+      Number number = new Number(1,94+i, i + 1 + i/8.0);
+      sheet.addCell(number);
+    }
+
+    label = new Label(0,100, "Formula from B27");
+    sheet.addCell(label);
+
+    wc = sheet.getWritableCell(1, 26).copyTo(1,100);
+    sheet.addCell(wc);
+
+    label = new Label(0,101, "A brand new formula");
+    sheet.addCell(label);
+    
+    Formula formula = new Formula(1, 101, "SUM(B94:B96)");
+    sheet.addCell(formula);
+
+    label = new Label(0,102, "A copy of it");
+    sheet.addCell(label);
+
+    wc = sheet.getWritableCell(1,101).copyTo(1, 102);
+    sheet.addCell(wc);
+
+    // Remove the second image from the sheet
+    WritableImage wi = sheet.getImage(1);
+    sheet.removeImage(wi);
+
+    wi = new WritableImage(1, 116, 2, 9, 
+                           new File("resources/littlemoretonhall.png"));
+    sheet.addImage(wi);
+
+    // Add a list data validations
+    label = new Label(0, 151, "Added drop down validation");
+    sheet.addCell(label);
+
+    Blank b = new Blank(1, 151);
+    wcf = new WritableCellFeatures();
+    ArrayList al = new ArrayList();
+    al.add("The Fellowship of the Ring");
+    al.add("The Two Towers");
+    al.add("The Return of the King");
+    wcf.setDataValidationList(al);
+    b.setCellFeatures(wcf);
+    sheet.addCell(b);
+
+    // Add a number data validation
+    label = new Label(0, 152, "Added number validation 2.718 < x < 3.142");
+    sheet.addCell(label);
+    b = new Blank(1,152);
+    wcf = new WritableCellFeatures();
+    wcf.setNumberValidation(2.718, 3.142, wcf.BETWEEN);
+    b.setCellFeatures(wcf);
+    sheet.addCell(b);
+
+    // Modify the text in the first cell with a comment
+    cell = sheet.getWritableCell(0, 156);
+    l = (Label) cell;
+    l.setString("Label text modified");
+
+    cell = sheet.getWritableCell(0, 157);
+    wcf = cell.getWritableCellFeatures();
+    wcf.setComment("modified comment text");
+
+    cell = sheet.getWritableCell(0, 158);
+    wcf = cell.getWritableCellFeatures();
+    wcf.removeComment();
+
+    // Modify the validation contents of the row 173
+    cell = sheet.getWritableCell(0,172);
+    wcf = cell.getWritableCellFeatures();
+    Range r = wcf.getSharedDataValidationRange();
+    Cell botright = r.getBottomRight();
+    sheet.removeSharedDataValidation(cell);
+    Al = new ArrayList();
+    al.add("Stanley Featherstonehaugh Ukridge");
+    al.add("Major Plank");
+    al.add("Earl of Ickenham");
+    al.add("Sir Gregory Parsloe-Parsloe");
+    al.add("Honoria Glossop");
+    al.add("Stiffy Byng");
+    al.add("Bingo Little");
+    wcf.setDataValidationList(al);
+    cell.setCellFeatures(wcf);
+    sheet.applySharedDataValidation(cell, 
+                                    botright.getColumn() - cell.getColumn(),
+                                    1);//botright.getRow() - cell.getRow());
+  }
+}
+
+
+
+
+
+
+
+
+
